//! This crate contains a number of analyses
//! that can be run on dependency graph generated by `guppy`
//! the types for holding data has `tabled` trait
//! for pretty display

use anyhow::{anyhow, Result};
use git2::{build::CheckoutBuilder, Oid, Repository};
use guppy::graph::{PackageGraph, PackageMetadata};
use guppy::MetadataCommand;
use separator::Separatable;
use std::collections::HashSet;
use std::path::Path;
use tabled::Tabled;

mod advisory;
mod code;
mod cratesio;
mod diff;
pub mod ghcomment;
mod github;
pub mod super_toml;
mod update;

use ghcomment::{Emoji::*, GitHubCommentGenerator, TextStyle::*};
use update::{CrateVersionRustSecAdvisory, UpdateReviewReport, VersionConflict};

// Usage metrics pulled from crates.io API
#[derive(Tabled, Clone)]
pub struct TabledCratesioReport {
    pub name: String,
    pub hosted_on_cratesio: bool,
    pub cratesio_downloads: u64,
    pub cratesio_dependents: u64,
}

// Usage, activity metrics pulled from GitHub API
#[derive(Tabled, Clone)]
pub struct TabledGitHubReport {
    pub name: String,
    pub hosted_on_github: bool,
    pub github_stars: u64,
    pub github_subscribers: u64,
    pub github_forks: u64,
    pub open_issues: u64,
    pub days_since_last_commit_on_default_branch: u64,
    pub days_since_last_open_issue: u64,
    pub open_issues_labeld_bug: u64,
    pub open_issues_labeled_security: u64,
    pub past_days_for_recent_stats: u64,
    pub recent_commits: u64,
    pub recent_committers: u64,
}

// Analaysis on difference between crates.io and git source
// for a crate version: difference is a potential red flag
#[derive(Tabled, Clone)]
pub struct TabledCrateSourceDiffReport {
    pub name: String,
    pub version: String,
    pub cratesio_source_diff_analyzed: bool,
    pub cratesio_different_from_source: bool,
    pub files_added: u64,
    pub files_modified: u64,
}

#[derive(Tabled, Default)]
pub struct TabledCodeReport {
    pub name: String,
    pub version: String,
    pub is_direct: bool,
    pub loc_analyzed: bool,
    pub total_loc: u64,
    pub rust_loc: u64,
    pub unsafe_analyzed: bool,
    pub forbids_unsafe: bool,
    pub unsafe_expressions: u64,
    pub has_build_script: bool,
    pub deps_analyzed: bool,
    pub total_deps: u64,
    pub deps_with_build_script: u64,
    pub deps_total_loc: u64,
    pub deps_total_rust_loc: u64,
    pub deps_analyzed_for_unsafe: u64,
    pub deps_forbidding_unsafe: u64,
    pub deps_using_unsafe: u64,
    pub deps_total_unsafe_expressions: u64,
}

pub struct InvidualDepReport {
    pub tabled_cratesio_report: TabledCratesioReport,
    pub tabled_github_report: TabledGitHubReport,
    pub tabled_crate_source_diff_report: TabledCrateSourceDiffReport,
}

pub struct DepDiveReport {
    pub crate_stats: Vec<InvidualDepReport>,
    pub code_stats: Vec<TabledCodeReport>,
}

pub struct DependencyAnalyzer;

impl DependencyAnalyzer {
    pub fn analyze_dep(&self, package: &PackageMetadata) -> Result<InvidualDepReport> {
        // let name = package.name().to_string();
        // let has_build_script = package.has_build_script();

        println!("analyzing crates.io metrics...");
        let cratesio_report = cratesio::CratesioAnalyzer::new()?;
        let cratesio_report = cratesio_report.analyze_cratesio(package)?;
        let tabled_cratesio_report = TabledCratesioReport {
            name: cratesio_report.name,
            hosted_on_cratesio: cratesio_report.is_hosted,
            cratesio_downloads: cratesio_report.downloads,
            cratesio_dependents: cratesio_report.dependents,
        };

        println!("analyzing github metrics...");
        let github_report = github::GitHubAnalyzer::new()?;
        let github_report = github_report.analyze_github(package)?;
        let tabled_github_report = TabledGitHubReport {
            name: github_report.name,
            hosted_on_github: github_report.is_github_repo,
            github_stars: github_report.repo_stats.stargazers_count,
            github_subscribers: github_report.repo_stats.subscribers_count,
            github_forks: github_report.repo_stats.forks,
            open_issues: github_report.repo_stats.open_issues,
            days_since_last_commit_on_default_branch: github_report
                .activity_metrics
                .days_since_last_commit,
            days_since_last_open_issue: github_report
                .activity_metrics
                .days_since_last_open_issue
                .unwrap_or(0),
            open_issues_labeld_bug: github_report.activity_metrics.open_issues_labeld_bug,
            open_issues_labeled_security: github_report
                .activity_metrics
                .open_issues_labeled_security,
            past_days_for_recent_stats: github_report.activity_metrics.recent_activity.past_days,
            recent_commits: github_report.activity_metrics.recent_activity.commits,
            recent_committers: github_report.activity_metrics.recent_activity.committers,
        };

        println!("analyzing difference in crates.io hosted source vs git source");
        let crate_source_report = diff::DiffAnalyzer::new()?;
        let crate_source_report = crate_source_report.analyze_crate_source_diff(
            package.name(),
            &package.version().to_string(),
            package.repository(),
        )?;

        let mut cratesio_source_diff_analyzed = false;
        let mut cratesio_different_from_source = false;
        let mut files_added = 0;
        let mut files_modified = 0;
        if crate_source_report.is_different.is_some() {
            cratesio_source_diff_analyzed = true;
            // If is_different has value then should below ones as well
            cratesio_different_from_source = crate_source_report.is_different.unwrap();
            let diff_report = crate_source_report.file_diff_stats.unwrap();
            files_added = diff_report.files_added.len() as u64;
            files_modified = diff_report.files_modified.len() as u64;
        }

        let tabled_crate_source_diff_report = TabledCrateSourceDiffReport {
            name: crate_source_report.name,
            version: crate_source_report.version,
            cratesio_source_diff_analyzed,
            cratesio_different_from_source,
            files_added,
            files_modified,
        };

        Ok(InvidualDepReport {
            tabled_cratesio_report,
            tabled_github_report,
            tabled_crate_source_diff_report,
        })
    }
}

pub struct DependencyGraphAnalyzer;

impl DependencyGraphAnalyzer {
    pub fn analyze_dep_graph(&self, graph: &PackageGraph) -> Result<DepDiveReport> {
        // Group stats
        println!("analyzing code metrics");
        let code_reports = code::CodeAnalyzer::new();
        let code_reports = code_reports.analyze_code(graph)?;
        let code_reports = code_reports
            .iter()
            .map(|r| Self::get_tabled_code_report(r.clone()))
            .collect();

        // Individual stats
        let direct_dependencies: Vec<_> = graph
            .query_workspace()
            .resolve_with_fn(|_, link| {
                // Collect direct dependencies of workspace packages.
                let (from, to) = link.endpoints();
                from.in_workspace() && !to.in_workspace()
            })
            .packages(guppy::graph::DependencyDirection::Forward)
            .filter(|pkg| !pkg.in_workspace())
            .collect();

        // Run Analysis on each direct dependency
        let reports: Vec<InvidualDepReport> = direct_dependencies
            .iter()
            .map(|pkg| DependencyAnalyzer.analyze_dep(pkg))
            .collect::<Result<_>>()?;

        Ok(DepDiveReport {
            crate_stats: reports,
            code_stats: code_reports,
        })
    }

    fn get_tabled_code_report(code_report: code::CodeReport) -> TabledCodeReport {
        let name = code_report.name;
        let version = code_report.version;
        let is_direct = code_report.is_direct;
        let has_build_script = code_report.has_build_script;

        let mut loc_analyzed = false;
        let mut total_loc = 0;
        let mut rust_loc = 0;
        if code_report.loc_report.is_some() {
            let loc_report = code_report.loc_report.unwrap();
            loc_analyzed = true;
            total_loc = loc_report.total_loc;
            rust_loc = loc_report.rust_loc;
        }

        let mut unsafe_analyzed = false;
        let mut forbids_unsafe = false;
        let mut unsafe_expressions = 0;
        if code_report.unsafe_report.is_some() {
            unsafe_analyzed = true;
            let unsafe_report = code_report.unsafe_report.unwrap();
            forbids_unsafe = unsafe_report.forbids_unsafe;
            unsafe_expressions = unsafe_report.used_unsafe_count.expressions;
        }

        let mut deps_analyzed = false;
        let mut total_deps = 0;
        let mut deps_with_build_script = 0;
        let mut deps_total_loc = 0;
        let mut deps_total_rust_loc = 0;
        let mut deps_analyzed_for_unsafe = 0;
        let mut deps_forbidding_unsafe = 0;
        let mut deps_using_unsafe = 0;
        let mut deps_total_unsafe_expressions = 0;
        if code_report.dep_report.is_some() {
            deps_analyzed = true;
            let dep_report = code_report.dep_report.unwrap();
            total_deps = dep_report.total_deps;
            deps_total_loc = dep_report.deps_total_loc_report.total_loc;
            deps_total_rust_loc = dep_report.deps_total_loc_report.rust_loc;
            deps_analyzed_for_unsafe = dep_report.deps_analyzed_for_unsafe;
            deps_forbidding_unsafe = dep_report.deps_forbidding_unsafe;
            deps_with_build_script = dep_report.deps_with_build_script;
            deps_using_unsafe = dep_report.deps_using_unsafe;
            deps_total_unsafe_expressions = dep_report.deps_total_used_unsafe_details.expressions;
        }

        TabledCodeReport {
            name,
            version,
            is_direct,
            loc_analyzed,
            total_loc,
            rust_loc,
            unsafe_analyzed,
            forbids_unsafe,
            unsafe_expressions,
            has_build_script,
            deps_analyzed,
            total_deps,
            deps_with_build_script,
            deps_total_loc,
            deps_total_rust_loc,
            deps_analyzed_for_unsafe,
            deps_forbidding_unsafe,
            deps_using_unsafe,
            deps_total_unsafe_expressions,
        }
    }
}

#[derive(Debug, Clone, Hash, PartialEq, Eq)]
pub struct AdvisoryHighlight {
    pub status: AdvisoryStatus,
    pub crate_name: String,
    pub id: String,
    pub url: Option<String>,
}

#[derive(Debug, Clone, Hash, PartialEq, Eq)]
pub enum AdvisoryStatus {
    Fixed,
    Introduced,
    Unfixed, // or, persistent, advisory is in both the versions
             // before and after of an update
}

pub struct UpdateAnalyzer;

impl UpdateAnalyzer {
    pub fn run_update_analyzer(
        prior_graph: &PackageGraph,
        post_graph: &PackageGraph,
    ) -> Result<UpdateReviewReport> {
        let update_analyzer = update::UpdateAnalyzer::new();
        update_analyzer.analyze_updates(&prior_graph, &post_graph)
    }

    pub fn get_summary_report(
        prior_graph: &PackageGraph,
        post_graph: &PackageGraph,
    ) -> Result<Option<String>> {
        let update_review_report = Self::run_update_analyzer(&prior_graph, &post_graph)?;
        if update_review_report.dep_update_review_reports.is_empty()
            && update_review_report.version_conflicts.is_empty()
        {
            return Ok(None);
        }

        let mut gh = GitHubCommentGenerator::new();

        // Flags for known and new advisory
        let mut advisory_highlights: HashSet<AdvisoryHighlight> = HashSet::new();

        // Write down info on updated dependencies
        gh.add_header("Dependency update review", 2);
        for report in &update_review_report.dep_update_review_reports {
            // Version update info
            gh.add_header(
                &format!(
                    "{} updated: {} --> {}",
                    report.name, report.prior_version.version, report.updated_version.version
                ),
                3,
            );

            // Advisory
            let mut details: String = String::new();
            let mut checkmark_table: Vec<Vec<&str>> = vec![vec![
                "No known advisories",
                GitHubCommentGenerator::get_checkmark(
                    report.updated_version.known_advisories.is_empty(),
                ),
            ]];

            // Keep track of advisory_highlights

            // a closure to add to advisory highlights set
            let mut add_to_advisory_highlights =
                |a: &CrateVersionRustSecAdvisory, status: AdvisoryStatus| {
                    advisory_highlights.insert(AdvisoryHighlight {
                        status,
                        crate_name: report.name.clone(),
                        id: a.id.clone(),
                        url: a.url.clone().map(|url| url.to_string()),
                    })
                };

            // Add to advisory highlights for current crate
            report
                .updated_version
                .known_advisories
                .iter()
                .for_each(|a| {
                    let status = if report.prior_version.known_advisories.contains(a) {
                        AdvisoryStatus::Unfixed
                    } else {
                        AdvisoryStatus::Introduced
                    };
                    add_to_advisory_highlights(&a, status);
                });
            report
                .prior_version
                .known_advisories
                .iter()
                .filter(|a| !report.updated_version.known_advisories.contains(a))
                .for_each(|a| {
                    add_to_advisory_highlights(&a, AdvisoryStatus::Fixed);
                });

            // a closure for generating hyperlink of an advisory
            let get_hyperlink = |a: &CrateVersionRustSecAdvisory| {
                if let Some(url) = &a.url {
                    GitHubCommentGenerator::get_hyperlink(&a.id, &url.to_string())
                } else {
                    a.id.clone()
                }
            };

            if !report.updated_version.known_advisories.is_empty() {
                let ids: Vec<String> = report
                    .updated_version
                    .known_advisories
                    .iter()
                    .map(|a| get_hyperlink(a))
                    .collect();
                gh.add_header(":bomb: The updated version contains known advisories", 3);
                gh.add_bulleted_list(&ids, &Plain);
            }

            let fixed_advisories: Vec<String> = report
                .prior_version
                .known_advisories
                .iter()
                .filter(|a| !report.updated_version.known_advisories.contains(a))
                .map(|a| get_hyperlink(a))
                .collect();
            if !fixed_advisories.is_empty() {
                gh.add_header(":tada: This update fixes known advisories", 3);
                gh.add_bulleted_list(&fixed_advisories, &Plain);
            }

            // Diff summary
            match &report.diff_stats {
                None => checkmark_table.push(vec![
                    "Depdive failed to get the diff between versions from crates.io",
                    GitHubCommentGenerator::get_emoji(Warning),
                ]),
                Some(stats) => {
                    // Diff overview
                    details.push_str(&GitHubCommentGenerator::get_collapsible_section(
                        "Click to show version diff summary",
                        &GitHubCommentGenerator::get_html_table(&[
                            vec![
                                "total files changed".to_string(),
                                stats.files_changed.len().separated_string(),
                            ],
                            vec![
                                "total rust files changed".to_string(),
                                stats.rust_files_changed.separated_string(),
                            ],
                            vec![
                                "total loc change".to_string(),
                                (stats.insertions + stats.deletions).separated_string(),
                            ],
                        ]),
                    ));

                    let changed_file_paths: Vec<String> =
                        stats.files_changed.iter().cloned().collect();
                    details.push_str(&GitHubCommentGenerator::get_collapsible_section(
                        "Click to show changed files",
                        &GitHubCommentGenerator::get_bulleted_list(&changed_file_paths, &Code),
                    ));

                    checkmark_table.push(vec![
                        "No change in the build script",
                        GitHubCommentGenerator::get_checkmark(
                            stats.modified_build_scripts.is_empty(),
                        ),
                    ]);
                    if !stats.modified_build_scripts.is_empty() {
                        let paths: Vec<String> =
                            stats.modified_build_scripts.iter().cloned().collect();
                        details.push_str(&GitHubCommentGenerator::get_collapsible_section(
                            "Click to show modified build scripts",
                            &GitHubCommentGenerator::get_bulleted_list(&paths, &Code),
                        ));
                    }

                    checkmark_table.push(vec![
                        "No change in any file with unsafe code",
                        GitHubCommentGenerator::get_checkmark(stats.unsafe_file_changed.is_empty()),
                    ]);
                    if !stats.unsafe_file_changed.is_empty() {
                        let paths: Vec<String> = stats
                            .unsafe_file_changed
                            .iter()
                            .map(|stats| stats.file.clone())
                            .collect();
                        details.push_str(&GitHubCommentGenerator::get_collapsible_section(
                            "Click to show changed files with unsafe code",
                            &GitHubCommentGenerator::get_bulleted_list(&paths, &Code),
                        ));
                    }
                }
            }

            if let Some(crate_source_diff_report) = &report.updated_version.crate_source_diff_report
            {
                match crate_source_diff_report.is_different {
                    None => {
                        checkmark_table.push(vec![
                            "Depdive failed to compare the crates.io code with its git source",
                            GitHubCommentGenerator::get_emoji(Warning),
                        ]);
                    }
                    Some(f) => {
                        checkmark_table.push(vec![
                            "The source and crates.io code are the same",
                            GitHubCommentGenerator::get_checkmark(!f),
                        ]);
                        if f {
                            let changed_files = crate_source_diff_report
                                .file_diff_stats
                                .as_ref()
                                .ok_or_else(|| {
                                anyhow!("Cannot locate file paths in git source diff report")
                            })?;
                            // Only added and modified files are of concern
                            let paths: Vec<String> = changed_files
                                .files_added
                                .union(&changed_files.files_modified)
                                .cloned()
                                .collect();
                            details.push_str(&GitHubCommentGenerator::get_collapsible_section(
                                "Click to show the files that differ in crates.io from the git source",
                                &GitHubCommentGenerator::get_bulleted_list(&paths, &Code),
                            ));
                        }
                    }
                }
            } else {
                return Err(anyhow!("no crates source diff report for the new version"));
            }

            gh.add_html_table(&checkmark_table);
            gh.add_collapsible_section("Cilck to show details", &details);
        }

        if !update_review_report.version_conflicts.is_empty() {
            let mut conflicts: Vec<String> = Vec::new();
            for conflict in &update_review_report.version_conflicts {
                match conflict {
                    VersionConflict::DirectTransitiveVersionConflict {
                        name,
                        direct_dep_version,
                        transitive_dep_version,
                    } => conflicts.push(format!(
                        "{} has version {} as a transitive dep but version {} as a direct dep",
                        name, transitive_dep_version, direct_dep_version
                    )),
                }
            }

            gh.add_collapsible_section(
                ":warning: Possible dependency Conflicts",
                &GitHubCommentGenerator::get_bulleted_list(&conflicts, &Plain),
            );
        }

        // Take advisory highlights to the top
        let advisory_banner = Self::get_advisory_banner(&advisory_highlights);
        Ok(Some(format!("{}\n{}", advisory_banner, gh.get_comment())))
    }

    fn get_advisory_banner(advisory_highlights: &HashSet<AdvisoryHighlight>) -> String {
        let mut advisory_banner: String = String::new();

        let introduced = advisory_highlights
            .iter()
            .filter(|a| a.status == AdvisoryStatus::Introduced)
            .count();
        if introduced > 0 {
            advisory_banner.push_str(&GitHubCommentGenerator::get_header_text(
                &format!(
                    ":bomb: This update introduces {} known {}\n",
                    introduced,
                    advisory_text(introduced)
                ),
                1,
            ));
        }

        let unfixed = advisory_highlights
            .iter()
            .filter(|a| a.status == AdvisoryStatus::Unfixed)
            .count();
        if unfixed > 0 {
            advisory_banner.push_str(&GitHubCommentGenerator::get_header_text(
                &format!(
                    ":bomb: {} known {} still unfixed\n",
                    unfixed,
                    advisory_text(unfixed)
                ),
                1,
            ));
        }

        let fixed = advisory_highlights
            .iter()
            .filter(|a| a.status == AdvisoryStatus::Fixed)
            .count();
        if fixed > 0 {
            advisory_banner.push_str(&GitHubCommentGenerator::get_header_text(
                &format!(
                    ":tada: This update fixes {} known {}\n",
                    fixed,
                    advisory_text(fixed)
                ),
                1,
            ));
        }

        fn advisory_text(n: usize) -> &'static str {
            if n == 1 {
                "advisory"
            } else {
                "advisories"
            }
        }

        advisory_banner
    }

    pub fn run_update_analyzer_from_repo_commits(
        path: &Path,
        commit_a: &str,
        commit_b: &str,
    ) -> Result<Option<String>> {
        let repo = Repository::open(&path)?;

        let mut checkout_builder = CheckoutBuilder::new();
        checkout_builder.force();

        // Get prior_graph
        repo.checkout_tree(
            &repo.find_object(Oid::from_str(commit_a)?, None)?,
            Some(&mut checkout_builder),
        )?;
        let prior_graph = MetadataCommand::new().current_dir(path).build_graph()?;

        // Get post_graph
        repo.checkout_tree(
            &repo.find_object(Oid::from_str(commit_b)?, None)?,
            Some(&mut checkout_builder),
        )?;
        let post_graph = MetadataCommand::new().current_dir(path).build_graph()?;

        UpdateAnalyzer::get_summary_report(&prior_graph, &post_graph)
    }

    pub fn run_update_analyzer_from_paths(path_a: &Path, path_b: &Path) -> Result<Option<String>> {
        let prior_graph = MetadataCommand::new().current_dir(path_a).build_graph()?;
        let post_graph = MetadataCommand::new().current_dir(path_b).build_graph()?;
        UpdateAnalyzer::get_summary_report(&prior_graph, &post_graph)
    }
}

#[cfg(test)]
mod test {
    use super::*;

    #[test]
    fn test_update_review_report_from_repo_commits() {
        let diff_analyzer = diff::DiffAnalyzer::new().unwrap();
        let name = "diem";
        let repository = "https://github.com/diem/diem";
        let repo = diff_analyzer.get_git_repo(name, repository).unwrap();
        let path = repo
            .path()
            .parent()
            .ok_or_else(|| anyhow!("repository path not found for {}", repository))
            .unwrap();
        println!(
            "{}",
            UpdateAnalyzer::run_update_analyzer_from_repo_commits(
                &path,
                "20da44ad0918e6f260e9f150a60f28ec3b8665b2",
                "2b2e529d96b6fbd9b5d111ecdd21acb61e95a28f"
            )
            .unwrap()
            .unwrap()
        );
    }

    #[test]
    fn test_update_review_report_from_paths() {
        let mut checkout_builder = CheckoutBuilder::new();
        checkout_builder.force();
        let da = diff::DiffAnalyzer::new().unwrap();

        let repo = da
            .get_git_repo(
                "test_a",
                "https://github.com/nasifimtiazohi/test-version-tag",
            )
            .unwrap();
        repo.checkout_tree(
            &repo
                .find_object(
                    Oid::from_str("43ffefddc15cc21725207e51f4d41d9931d197f2").unwrap(),
                    None,
                )
                .unwrap(),
            Some(&mut checkout_builder),
        )
        .unwrap();
        let path_a = repo.path().parent().unwrap();

        // Get post_graph
        let repo = da
            .get_git_repo(
                "test_b",
                "https://github.com/nasifimtiazohi/test-version-tag",
            )
            .unwrap();
        repo.checkout_tree(
            &repo
                .find_object(
                    Oid::from_str("96a541d081863875b169fc88cd8f58bbd268d377").unwrap(),
                    None,
                )
                .unwrap(),
            Some(&mut checkout_builder),
        )
        .unwrap();
        let path_b = repo.path().parent().unwrap();

        println!(
            "{}",
            UpdateAnalyzer::run_update_analyzer_from_paths(&path_a, &path_b)
                .unwrap()
                .unwrap()
        );
    }

    #[test]
    fn test_for_no_updates() {
        let diff_analyzer = diff::DiffAnalyzer::new().unwrap();
        let name = "diem";
        let repository = "https://github.com/diem/diem";
        let repo = diff_analyzer.get_git_repo(name, repository).unwrap();
        let path = repo
            .path()
            .parent()
            .ok_or_else(|| anyhow!("repository path not found for {}", repository))
            .unwrap();
        assert!(UpdateAnalyzer::run_update_analyzer_from_repo_commits(
            &path,
            "516b1d9cb619de459da0ba07e8fd74743d2fa9a0",
            "44f91c93c0d0b522bac22d90028698e392fada41"
        )
        .unwrap()
        .is_none());
    }
}
