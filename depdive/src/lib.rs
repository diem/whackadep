//! This crate contains a number of analyses
//! that can be run on dependency graph generated by `guppy`
//! the types for holding data has `tabled` trait
//! for pretty display

use anyhow::Result;
use guppy::graph::{PackageGraph, PackageMetadata};
use tabled::Tabled;

mod code;
mod cratesio;
mod diff;
mod github;
mod update;

// Usage metrics pulled from crates.io API
#[derive(Tabled, Clone)]
pub struct TabledCratesioReport {
    pub name: String,
    pub hosted_on_cratesio: bool,
    pub cratesio_downloads: u64,
    pub cratesio_dependents: u64,
}

// Usage, activity metrics pulled from GitHub API
#[derive(Tabled, Clone)]
pub struct TabledGitHubReport {
    pub name: String,
    pub hosted_on_github: bool,
    pub github_stars: u64,
    pub github_subscribers: u64,
    pub github_forks: u64,
    pub open_issues: u64,
    pub days_since_last_commit_on_default_branch: u64,
    pub days_since_last_open_issue: u64,
    pub open_issues_labeld_bug: u64,
    pub open_issues_labeled_security: u64,
    pub past_days_for_recent_stats: u64,
    pub recent_commits: u64,
    pub recent_committers: u64,
}

// Analaysis on difference between crates.io and git source
// for a crate version: difference is a potential red flag
#[derive(Tabled, Clone)]
pub struct TabledCrateSourceDiffReport {
    pub name: String,
    pub version: String,
    pub cratesio_source_diff_analyzed: bool,
    pub cratesio_different_from_source: bool,
    pub files_added: u64,
    pub files_modified: u64,
}

#[derive(Tabled, Default)]
pub struct TabledCodeReport {
    pub name: String,
    pub version: String,
    pub is_direct: bool,
    pub loc_analyzed: bool,
    pub total_loc: u64,
    pub rust_loc: u64,
    pub unsafe_analyzed: bool,
    pub forbids_unsafe: bool,
    pub unsafe_expressions: u64,
    pub has_build_script: bool,
    pub deps_analyzed: bool,
    pub total_deps: u64,
    pub deps_with_build_script: u64,
    pub deps_total_loc: u64,
    pub deps_total_rust_loc: u64,
    pub deps_analyzed_for_unsafe: u64,
    pub deps_forbidding_unsafe: u64,
    pub deps_using_unsafe: u64,
    pub deps_total_unsafe_expressions: u64,
}

pub struct InvidualDepReport {
    pub tabled_cratesio_report: TabledCratesioReport,
    pub tabled_github_report: TabledGitHubReport,
    pub tabled_crate_source_diff_report: TabledCrateSourceDiffReport,
}

pub struct DepDiveReport {
    pub crate_stats: Vec<InvidualDepReport>,
    pub code_stats: Vec<TabledCodeReport>,
}

pub struct DependencyAnalyzer;

impl DependencyAnalyzer {
    pub fn analyze_dep(&self, package: &PackageMetadata) -> Result<InvidualDepReport> {
        // let name = package.name().to_string();
        // let has_build_script = package.has_build_script();

        println!("analyzing crates.io metrics...");
        let cratesio_report = cratesio::CratesioAnalyzer::new()?;
        let cratesio_report = cratesio_report.analyze_cratesio(package)?;
        let tabled_cratesio_report = TabledCratesioReport {
            name: cratesio_report.name,
            hosted_on_cratesio: cratesio_report.is_hosted,
            cratesio_downloads: cratesio_report.downloads,
            cratesio_dependents: cratesio_report.dependents,
        };

        println!("analyzing github metrics...");
        let github_report = github::GitHubAnalyzer::new()?;
        let github_report = github_report.analyze_github(package)?;
        let tabled_github_report = TabledGitHubReport {
            name: github_report.name,
            hosted_on_github: github_report.is_github_repo,
            github_stars: github_report.repo_stats.stargazers_count,
            github_subscribers: github_report.repo_stats.subscribers_count,
            github_forks: github_report.repo_stats.forks,
            open_issues: github_report.repo_stats.open_issues,
            days_since_last_commit_on_default_branch: github_report
                .activity_metrics
                .days_since_last_commit,
            days_since_last_open_issue: github_report
                .activity_metrics
                .days_since_last_open_issue
                .unwrap_or(0),
            open_issues_labeld_bug: github_report.activity_metrics.open_issues_labeld_bug,
            open_issues_labeled_security: github_report
                .activity_metrics
                .open_issues_labeled_security,
            past_days_for_recent_stats: github_report.activity_metrics.recent_activity.past_days,
            recent_commits: github_report.activity_metrics.recent_activity.commits,
            recent_committers: github_report.activity_metrics.recent_activity.committers,
        };

        println!("analyzing difference in crates.io hosted source vs git source");
        let crate_source_report = diff::DiffAnalyzer::new()?;
        let crate_source_report = crate_source_report.analyze_crate_source_diff(package)?;

        let mut cratesio_source_diff_analyzed = false;
        let mut cratesio_different_from_source = false;
        let mut files_added = 0;
        let mut files_modified = 0;
        if crate_source_report.is_different.is_some() {
            cratesio_source_diff_analyzed = true;
            // If is_different has value then should below ones as well
            cratesio_different_from_source = crate_source_report.is_different.unwrap();
            let diff_report = crate_source_report.file_diff_stats.unwrap();
            files_added = diff_report.files_added;
            files_modified = diff_report.files_modified;
        }

        let tabled_crate_source_diff_report = TabledCrateSourceDiffReport {
            name: crate_source_report.name,
            version: crate_source_report.version,
            cratesio_source_diff_analyzed,
            cratesio_different_from_source,
            files_added,
            files_modified,
        };

        Ok(InvidualDepReport {
            tabled_cratesio_report,
            tabled_github_report,
            tabled_crate_source_diff_report,
        })
    }
}

pub struct DependencyGraphAnalyzer;

impl DependencyGraphAnalyzer {
    pub fn analyze_dep_graph(&self, graph: &PackageGraph) -> Result<DepDiveReport> {
        // Group stats
        println!("analyzing code metrics");
        let code_reports = code::CodeAnalyzer::new();
        let code_reports = code_reports.analyze_code(graph)?;
        let code_reports = code_reports
            .iter()
            .map(|r| Self::get_tabled_code_report(r.clone()))
            .collect();

        // Individual stats
        let direct_dependencies: Vec<_> = graph
            .query_workspace()
            .resolve_with_fn(|_, link| {
                // Collect direct dependencies of workspace packages.
                let (from, to) = link.endpoints();
                from.in_workspace() && !to.in_workspace()
            })
            .packages(guppy::graph::DependencyDirection::Forward)
            .filter(|pkg| !pkg.in_workspace())
            .collect();

        // Run Analysis on each direct dependency
        let reports: Vec<InvidualDepReport> = direct_dependencies
            .iter()
            .map(|pkg| DependencyAnalyzer.analyze_dep(pkg))
            .collect::<Result<_>>()?;

        Ok(DepDiveReport {
            crate_stats: reports,
            code_stats: code_reports,
        })
    }

    fn get_tabled_code_report(code_report: code::CodeReport) -> TabledCodeReport {
        let name = code_report.name;
        let version = code_report.version;
        let is_direct = code_report.is_direct;
        let has_build_script = code_report.has_build_script;

        let mut loc_analyzed = false;
        let mut total_loc = 0;
        let mut rust_loc = 0;
        if code_report.loc_report.is_some() {
            let loc_report = code_report.loc_report.unwrap();
            loc_analyzed = true;
            total_loc = loc_report.total_loc;
            rust_loc = loc_report.rust_loc;
        }

        let mut unsafe_analyzed = false;
        let mut forbids_unsafe = false;
        let mut unsafe_expressions = 0;
        if code_report.unsafe_report.is_some() {
            unsafe_analyzed = true;
            let unsafe_report = code_report.unsafe_report.unwrap();
            forbids_unsafe = unsafe_report.forbids_unsafe;
            unsafe_expressions = unsafe_report.used_unsafe_count.expressions;
        }

        let mut deps_analyzed = false;
        let mut total_deps = 0;
        let mut deps_with_build_script = 0;
        let mut deps_total_loc = 0;
        let mut deps_total_rust_loc = 0;
        let mut deps_analyzed_for_unsafe = 0;
        let mut deps_forbidding_unsafe = 0;
        let mut deps_using_unsafe = 0;
        let mut deps_total_unsafe_expressions = 0;
        if code_report.dep_report.is_some() {
            deps_analyzed = true;
            let dep_report = code_report.dep_report.unwrap();
            total_deps = dep_report.total_deps;
            deps_total_loc = dep_report.deps_total_loc_report.total_loc;
            deps_total_rust_loc = dep_report.deps_total_loc_report.rust_loc;
            deps_analyzed_for_unsafe = dep_report.deps_analyzed_for_unsafe;
            deps_forbidding_unsafe = dep_report.deps_forbidding_unsafe;
            deps_with_build_script = dep_report.deps_with_build_script;
            deps_using_unsafe = dep_report.deps_using_unsafe;
            deps_total_unsafe_expressions = dep_report.deps_total_used_unsafe_details.expressions;
        }

        TabledCodeReport {
            name,
            version,
            is_direct,
            loc_analyzed,
            total_loc,
            rust_loc,
            unsafe_analyzed,
            forbids_unsafe,
            unsafe_expressions,
            has_build_script,
            deps_analyzed,
            total_deps,
            deps_with_build_script,
            deps_total_loc,
            deps_total_rust_loc,
            deps_analyzed_for_unsafe,
            deps_forbidding_unsafe,
            deps_using_unsafe,
            deps_total_unsafe_expressions,
        }
    }
}

pub struct UpdateAnalyzer;

impl UpdateAnalyzer {
    pub fn update_review(prior_graph: &PackageGraph, post_graph: &PackageGraph) -> Result<()> {
        let update_analyzer = update::UpdateAnalyzer::new();
        update_analyzer.analyze_updates(&prior_graph, &post_graph)?;
        Ok(())
    }
}
